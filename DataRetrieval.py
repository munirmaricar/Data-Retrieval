# -*- coding: utf-8 -*-
"""Data Retrieval.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ZB2bU2Qw_zVEyoQLgQhFF8sXMYPymQBf

***CODE INITIALISATION*: Install the necessary libraries by executing the installation part of the code.**
"""

import numpy as np
import pandas as pd
import urllib.request
import requests
import camelot
import sys
import os
from zipfile import *
from datetime import *
from bs4 import BeautifulSoup
from urllib.parse import urljoin
!pip install "camelot-py[cv, plot]"
!apt install python3-tk ghostscript

"""***Steps for Executing Code:***

1. Create a new empty folder called `Quarterly_Data`. This will store all the historical quarterly datasets.

2.   If the user does not have the relevant files needed for the program available on his/her Google Drive account, they can download the files using the program. 

3. Once the files necessary have been downloaded, they must be uploaded to their Google Drive account by following the steps below:
    * Create a folder called `Data Retreival`.
    *   The Holding Company Name List, obtained from the [Federal Reserve Bank of Chicago](https://www.chicagofed.org/~/media/others/banking/financial-institution-reports/hc-name-list-pdf.pdf?la=en), must be converted to a CSV file and should be named as `List.csv`.
    *   The Historical Quarterly Datasets, obtained from the [Federal Reserve Bank of Chicago](https://www.chicagofed.org/banking/financial-institution-reports/bhc-data), must be in the form of CSV files and should be stored in the `Quarterly_Data` folder.
    *   The MDRM Dictionary, obtained from the [Federal Reserve](https://www.federalreserve.gov/apps/mdrm/download_mdrm.htm), must be in the form of a CSV file and should be named as `Dictionary.csv`.
    * The `Quarterly_Data` folder along with the `List.csv` and `Dictionary.csv` files must be moved to the `Data Retrieval` folder.
    * Upload the `Data Retrieval` folder to their Google Drive account.
    * Make a note of the path of the `Data Retrieval` folder in their Google Drive.

4. Mount Google Drive to the Google Colab repository by signing in it to your Google account.

5.   There are two ways of executing the code:
    *  The user wants to find the information for one specific institution by providing the starting/ending date filters, the RSSD ID, the name of the institution, the item that the user is looking for, and the reporting form for that item.
    * The user wants to find the information for several institutions by using a CSV file called `Banks.csv` only containing the *case sensitive* headers `RSSD ID` and `Name of Institution`. A different CSV file called `Codes.csv` only containing the *case sensitive* header `Item Code` must also be provided. The `Banks.csv` and `Codes.csv` files must also be uploaded to the `Data Retrieval` folder mentioned in *Step 3*. After this, the user must set the starting/ending date filters to finalise the search query.

6. Execute any version of the code and provide the relevant inputs.

"""

# Importing the previously installed libraries.


# This function is used to download all the historical quarterly datasets in the
# form of CSV files and stores them in the Quarterly_Data folder.
def downloadHistoricalQuarterlyDatasets(link):

    # This is used to open the link provided as an argument to the function.
    response = requests.get(link)

    # This variable obtains the HTML code for the webpage.
    soup = BeautifulSoup(response.text, "html.parser")

    # We iterate through all the CSVs available in the webpage.
    for url in soup.select("a[href$='.csv']"):

        # We name the CSV files using the last portion of each link which
        # are unique.
        filename = url['href'].split('/')[-1]

        # If the file has successfully been downloaded, we make a note of
        # it.
        with open("Quarterly_Data/" + filename, 'wb') as f:
            f.write(requests.get(urljoin(link, url['href'])).content)


# This function is used to download the holding company name list in the
# form of a PDF file.
def downloadHoldingCompanyNameList(link):

    # This is used to open the link provided as an argument to the function.
    response = urllib.request.urlopen(link)

    # This opens the file in a binary-write mode.
    file = open("List.pdf", 'wb')

    # If the file has successfully been downloaded, we make a note of it.
    file.write(response.read())

    # We close the file.
    file.close()


# This function is used to download the Micro Data Reference Manual Dictionary
# in the form of a ZIP folder. Then, it extracts the folder and only saves the
# Dictionary in the form of a CSV file while deleting the unwanted files.
def downloadMicroDataReferenceManual(link):

    # This is used to open the link provided as an argument to the function.
    r = requests.get(link, stream=True)

    # We open the downloaded ZIP folder.
    with open("MDRM.zip", 'wb') as fd:

        # This is used to iterate through the ZIP folder to see the files it
        # contains.
        for chunk in r.iter_content(chunk_size=128):

            # We are storing the items found within the ZIP folder.
            fd.write(chunk)

    # We are creating a ZipFile object and loading the downloaded ZIP folder
    # into it.
    with ZipFile('MDRM.zip', 'r') as zipObj:

        # This is used to extract all the contents of the ZIP folder to the
        # current directory.
        zipObj.extractall()

    # This is used to rename the CSV file to be consistent with the naming
    # standards.
    os.rename("MDRM_CSV.csv", "Dictionary.csv")

    # This is to remove files that are irrelevant to the running of the program.
    os.remove("README File for MDRM.txt")
    os.remove("MDRM.zip")


# This function uses a Python library called Camelot to convert the holding
# company name list in the form of a PDF file to a CSV file that is useful for
# our program. Then, it deletes the PDF version of the list as it is no longer
# needed.
def convertPDFtoCSV(fileName, outputFileName):

    # This variable is used to store the list of dataframes that we obtained as
    # a result of converting the file.
    listOfDataframes = []

    # Camelot reads through all the pages of the PDF and returns a list of table
    # objects.
    tables = camelot.read_pdf(fileName, flavor="stream", edge_tol=1000,
                              pages="1 - end",
                              table_areas=["15, 570, 760, 40"],
                              columns=["55, 100, 360, 460, 550, 610, 670"],
                              split_text=True)

    # We are iterating through all the tables, converting them into a Pandas
    # dataframe and adding them to the list of dataframes we initialised before.
    for table in tables:
        listOfDataframes.append(table.df)

    # This is used to merge all the dataframes in the list of dataframes into a
    # single dataframe.
    outputDataframe = pd.concat(listOfDataframes)

    # This converts the dataframe resulted into a CSV file that we can use later
    # in the program.
    outputDataframe.to_csv(outputFileName, index=False)

    # This deletes the initial PDF file that is no longer needed.
    os.remove(fileName)


# This function is used to find the list of files we can obtain data from
# according to the dates provided by the user as input.
def findListOfQuarterlyDatasetsFromDates(startDate, endDate,
                                         listOfQuarterlyDatasets):

    # This variable is used to store the list of files that are compatible with
    # the starting and ending date filters provided by the user.
    listOfQuarterlyDatasetsFromDates = []

    # We are iterating through all the quarterly historical datasets.
    for fileName in listOfQuarterlyDatasets:

        # This converts the filename to a date that can be used to compare with
        # the starting and ending dates.
        fileDate = datetime.strptime(fileName[4:8] + "30", "%y%m%d")

        # We are checking if the filename lies in between the filter dates.
        if ((startDate <= fileDate) and (endDate >= fileDate)):

            # If it does, we add it to the list variable we created earlier.
            listOfQuarterlyDatasetsFromDates.append(fileName)

    # We return the list of filenames that are compatible with the input dates.
    return listOfQuarterlyDatasetsFromDates


# This function is used to read the MDRM dictionary and returns a list of item
# codes that corresponds to the item name and reporting form that was requested
# by the user. The item codes must also satisfy the dates criteria.
def readDictionaryDataframe(startDate, endDate, itemName, reportingForm,
                            folderPath):

    # We are reading the Dictionary.csv file and converting it into a Pandas
    # dataframe so we can see every element of the MDRM dictionary and find the
    # code for each item name. The header of the dataframe needs adjusting due
    # to the layout of the CSV file.
    dictionaryDataframe = pd.read_csv(folderPath + "/Dictionary.csv")
    dictionaryDataframe.columns = dictionaryDataframe.iloc[0]
    dictionaryDataframe = dictionaryDataframe.drop([0])

    # This list is used to store the different codes used to represent the item
    # name that was requested by the user.
    listOfItemCodes = []

    # We are iterating through the MDRM dictionary to find the item code for the
    # item name requested by the user.
    for index, row in dictionaryDataframe.iterrows():

        # This variable stores the starting date for the MDRM dictionary data.
        currentStartDate = datetime.strptime(row["Start Date"].split(" ")[0],
                                             "%m/%d/%Y")

        # This variable stores the ending date for the MDRM dictionary data.
        currentEndDate = datetime.strptime(row["End Date"].split(" ")[0],
                                           "%m/%d/%Y")

        # This variable stores the current row's item code for the MDRM
        # dictionary data.
        currentCode = str(row["Item Code"])

        # Some of the reporting forms are unavailable and hence, result in the
        # cell being occupied as NaN. This block of code is used to convert an
        # unavailable reporting form cell from NaN to a simple empty string.
        try:
            currentReportingForm = float(row["Reporting Form"])
            currentReportingForm = ""
        except:
            currentReportingForm = row["Reporting Form"]

        # This is used to check if the item name is what the user requested as
        # well as if the starting date and ending date match with the input of
        # the user.
        if ((startDate <= currentEndDate) and (endDate > currentStartDate) and
            (row["Item Name"].upper() == itemName.upper()) and
                (currentReportingForm == reportingForm)):

            # In some cases, item codes might need zeros to be padded in front
            # of them.
            for i in range(4 - len(currentCode)):
                currentCode = "0" + currentCode

            # The item code is the combination of the mnemonic as well as the
            # code obtained from the dictionary.
            itemCode = row["Mnemonic"] + currentCode

            # We append the item code to the list we created earlier keeping
            # track of all the different item codes. This is because there may
            # be several item codes that correspond to the same item name.
            listOfItemCodes.append(itemCode)

    # If the combination of the function arguments cannot be found in the
    # dictionary, the user input must be mistaken and hence, we exit the
    # program and ask the user to try again.
    if listOfItemCodes == []:
        sys.exit("\nThe combination of inputs provided yielded no results. Pl" +
                 "ease run the program again \nwith different inputs!")

    # We are returning a list of codes that correspond to the item name that the
    # user requested.
    return listOfItemCodes


# This function is used to read the holding company name list and returns a list
# of relevant data that is needed in the output. This relevant data must satisfy
# the rssdID, institutionName and the date criterias.
def readListDataframe(rssdID, institutionName, startDate, endDate, folderPath):

    # We are reading the List.csv file and we are converting it into a Pandas
    # dataframe so we can obtain the relevant information from it. The header of
    # the dataframe needs adjusting due to the layout of the CSV file.
    listDataframe = pd.read_csv(folderPath + "/List.csv")
    listDataframe.columns = listDataframe.iloc[0]
    listDataframe = listDataframe.drop([0])

    # This list is used to store the relevant output data elements that we will
    # need later.
    listOfOutputElements = []

    # We are iterating through the holding company name list to find the
    # relevant information needed for our output.
    for index, row in listDataframe.iterrows():

        # Sometimes, the name of the institution is so long that it extends to
        # the next record. In such a case, we simply truncate the name.
        try:

            # We are assigning the current company's opening date.
            currentStartDate = datetime.strptime(str(row["DATE OPEN"]),
                                                 "%Y%m%d")

            # We are checking if the ending date is given in the List.csv file.
            # If not, we assume that the ending date is the 31st of March, 2021.
            if np.isnan(float(row["NAME END DATE"])):
                currentEndDate = datetime.strptime("20210331", "%Y%m%d")
            else:
                currentEndDate = datetime.strptime(str(row["NAME END DATE"]),
                                                   "%Y%m%d")
        except:
            continue

        # This is used to check if the data matches with the user input.
        if ((startDate <= currentEndDate) and (endDate > currentStartDate) and
            (row["ID_RSSD"] == rssdID) and
                (row["NAME"].upper() == institutionName.upper())):

            # We are appending the data that is relevant for the output to the
            # list we created earlier.
            listOfOutputElements.append(row["ENTITY TYPE"])
            listOfOutputElements.append(row["ST / COUNTRY"])
            listOfOutputElements.append(row["REGULATORY DISTRICT"])

    # If the combination of the function arguments cannot be found in the
    # list, the user input must be mistaken and hence, we exit the program
    # and ask the user to try again.
    if listOfOutputElements == []:
        sys.exit("\nThe combination of inputs provided yielded no results. Pl" +
                 "ease run the program again \nwith different inputs! ")

    # We are returning a list of elements that we will need for the output
    # later.
    return listOfOutputElements


# This function is used to read the relevant quarterly historic datasets and
# finds the missing information that is needed to display the output.
def readMainDataframe(rssdID, institutionName, startDateString, endDateString,
                      itemName, reportingForm, folderPath,
                      listOfQuarterlyDatasets):

    # We create an appropriate output dataframe with four different columns as
    # requested.
    outputDataframe = pd.DataFrame(columns=['RSSD ID', 'Entity Type', 'Name' +
                                            ' of Institution', 'State or Co' +
                                            'untry', 'Start Date', 'End Date',
                                            'Regulatory District', 'Mnemoni' +
                                            'c and Item Code', itemName, 'D' +
                                            'ate of Information Collection',
                                            'Reporting Form'])

    # We convert the ending date provided as user input into a format that can
    # be manipulated.
    if endDateString != "":
        endDate = datetime.strptime(endDateString, '%d/%m/%Y')

    # If the input provided by the user is empty (meaning the case is still
    # ongoing), we assume that the ending date is the 31st of March, 2021.
    else:
        endDate = datetime.strptime("31/03/2021", '%d/%m/%Y')

    # We convert the starting date provided as user input into a format that can
    # be manipulated.
    startDate = datetime.strptime(startDateString, '%d/%m/%Y')

    # This variable is used to store the list of files that are compatible with
    # the starting and ending date filters provided by the user using a function
    # we defined previously.
    listOfCompatibleFiles = findListOfQuarterlyDatasetsFromDates(startDate,
                                                                 endDate, listOfQuarterlyDatasets)

    # This variable is used to store the different codes used to represent the
    # item name that was requested by the user using a function we defined
    # previously.
    listOfItemCodes = readDictionaryDataframe(startDate, endDate, itemName,
                                              reportingForm, folderPath)

    # This variable is used to store the relevant output data elements that we
    # will need later using a function we defined previously.
    listOfHoldingCompanyData = readListDataframe(rssdID, institutionName,
                                                 startDate, endDate, folderPath)

    # If the reporting form user input is left blank because it was unavailable,
    # we change the variable to "Unavailable".
    if reportingForm == "":
        tempReportingForm = "Unavailable"
    else:
        tempReportingForm = reportingForm

    # We are iterating through the files that are compatible with the input
    # dates to find the information regarding the items requested by the user.
    for fileName in listOfCompatibleFiles:

        # We are reading one of the quarterly historic dataset files and we are
        # converting it into a Pandas dataframe so we can obtain the relevant
        # information from it.
        mainDataframe = pd.read_csv(folderPath + "/Quarterly_Data/" + fileName,
                                    engine="python")

        # We are iterating through the specific quarterly historic dataset file
        # to find if there are any items that we can include in our output.
        for index, row in mainDataframe.iterrows():

            # Since the headers of different quarterly historic datasets differ,
            # we have two different ways to read the ID and the dates from it.
            try:
                id = str(row["rssd9001"])
                dateOfCollection = datetime.strptime(str(row["rssd9999"]),
                                                     "%Y%m%d")
            except:
                id = str(row["RSSD9001"])
                if id == "--------":
                    continue
                dateOfCollection = datetime.strptime(str(row["RSSD9999"]),
                                                     "%Y%m%d")

            # We are converting the date the item was recorded into a string
            # that can be used in the output.
            outputDateOfCollection = dateOfCollection.strftime("%d/%m/%Y")

            # This is used to check if the RSSD ID matches with the user input.
            if (id == rssdID):

                # If we have multiple item codes, we are finding the value for
                # each of them.
                for itemCode in listOfItemCodes:

                    # We are checking if the value of the item requested is
                    # valid or not. If it is valid, we add the relevant data
                    # including the value of the item to the outputDataframe we
                    # created earlier.
                    try:
                        outputItemName = float(row[itemCode])
                        if np.isnan(outputItemName):
                            raise Exception("Value invalid!")
                        outputDataframe = outputDataframe.append({'RSSD ID':
                                                                  rssdID, 'Entity Type':
                                                                  listOfHoldingCompanyData[0], 'Nam' +
                                                                  'e of Institution': institutionName,
                                                                  'State or Country':
                                                                  listOfHoldingCompanyData[1], 'Sta' +
                                                                  'rt Date': startDateString, 'End ' +
                                                                  'Date': endDateString, 'Regulator' +
                                                                  'y District':
                                                                  listOfHoldingCompanyData[2], 'Mne' +
                                                                  'monic and Item Code': itemCode,
                                                                  itemName: outputItemName, 'Date o' +
                                                                  'f Information Collection':
                                                                  outputDateOfCollection, 'Reportin' +
                                                                  'g Form': tempReportingForm},
                                                                 ignore_index=True)

                    # If the value of the item requested is invalid, we continue
                    # to the next iteration of the loop.
                    except:
                        continue

    # We are returning the dataframe that must be converted to a CSV file for
    # the output.
    return outputDataframe


# This function is used to read the different CSV files and output the relevant
# information after considering the appropriate filters given as input. The
# output is given in the form of a CSV file.
def dataRetrieval(startDateString, endDateString, rssdID, institutionName,
                  itemName, reportingForm, folderPath, listOfQuarterlyDatasets):

    # This variable is a Pandas dataframe containing the relevant output
    # information using a function we defined earlier.
    outputDataframe = readMainDataframe(rssdID, institutionName,
                                        startDateString, endDateString,
                                        itemName, reportingForm, folderPath,
                                        listOfQuarterlyDatasets)

    # If the outputDataframe has no records, it means the search yielded no
    # results.
    if outputDataframe.empty:
        sys.exit("\nThe combination of inputs provided yielded no results. Pl" +
                 "ease run the program again \nwith different inputs! ")

    # If the outputDataframe is not empty, we convert it into an Output.csv file
    # which can be viewed by the user.
    else:
        outputDataframe.to_csv('Output.csv')
        print()
        print("Please open the Output.csv file to see the result of your sear" +
              "ch criteria.")


# This function is used to read the MDRM dictionary and returns a list of lists
# containing item code, item name and reporting form for every item code that
# was provided in the Codes.csv file.
def readDictionaryDataframeInBatches(startDate, endDate, folderPath):

    # We are reading the Dictionary.csv file and converting it into a Pandas
    # dataframe so we can see every element of the MDRM dictionary and find the
    # code for each item name. The header of the dataframe needs adjusting due
    # to the layout of the CSV file.
    dictionaryDataframe = pd.read_csv(folderPath + "/Dictionary.csv")
    dictionaryDataframe.columns = dictionaryDataframe.iloc[0]
    dictionaryDataframe = dictionaryDataframe.drop([0])

    # This list is used to store the different codes that was provided in the
    # Codes.csv file.
    listOfItemCodes = []

    # We are reading the Codes.csv file and converting it into a Pandas
    # dataframe so we can get every item code from it.
    codesDataframe = pd.read_csv(folderPath + "/Codes.csv")

    # We are iterating through the codes dataframe to add every item code to the
    # listOfItemCodes we initialised earlier.
    for index, row in codesDataframe.iterrows():
        listOfItemCodes.append(row["Item Code"])

    # This list is used to store the different information for each item code
    # available in the listOfItemCodes.
    listOfDictionaryInformation = []

    # We are iterating through the MDRM dictionary to find the item code for the
    # item name requested by the user.
    for index, row in dictionaryDataframe.iterrows():

        # This variable stores the starting date for the MDRM dictionary data.
        currentStartDate = datetime.strptime(row["Start Date"].split(" ")[0],
                                             "%m/%d/%Y")

        # This variable stores the ending date for the MDRM dictionary data.
        currentEndDate = datetime.strptime(row["End Date"].split(" ")[0],
                                           "%m/%d/%Y")

        # This variable stores the current row's item name for the MDRM
        # dictionary data.
        currentItemName = str(row["Item Name"])

        # This variable stores the current row's item code for the MDRM
        # dictionary data.
        currentCode = str(row["Item Code"])

        # In some cases, item codes might need zeros to be padded in front
        # of them.
        for i in range(4 - len(currentCode)):
            currentCode = "0" + currentCode

        # The item code is the combination of the mnemonic as well as the
        # code obtained from the dictionary.
        currentItemCode = row["Mnemonic"] + currentCode

        # Some of the reporting forms are unavailable and hence, result in the
        # cell being occupied as NaN. This block of code is used to convert an
        # unavailable reporting form cell from NaN to a simple empty string.
        try:
            currentReportingForm = float(row["Reporting Form"])
            currentReportingForm = ""
        except:
            currentReportingForm = row["Reporting Form"]

        # We are iterating through every item code available in the
        # listOfItemCodes and we are adding information regarding it to the
        # listOfDictionaryInformation we initialised earlier.
        for itemCode in listOfItemCodes:

            # This is used to check if the item name is what the user requested
            # as well as if the starting date and ending date match with the
            # input of the user.
            if ((startDate <= currentEndDate) and (endDate > currentStartDate)
                    and (currentItemCode == itemCode)):

                # We append the item code, the item name, and the reporting form
                # to the list we created earlier keeping track of all the
                # different item codes.
                listOfDictionaryInformation.append([currentItemCode,
                                                    currentItemName,
                                                    currentReportingForm])

    # If the combination of the function arguments cannot be found in the
    # dictionary, the user input must be mistaken and hence, we exit the
    # program and ask the user to try again.
    if listOfDictionaryInformation == []:
        sys.exit("\nThe combination of inputs provided yielded no results. Pl" +
                 "ease run the program again \nwith different inputs! ")

    # We are returning a list of codes that correspond to the item name that the
    # user requested.
    return listOfDictionaryInformation


# This function is used to read the different CSV files and output the relevant
# information after considering the appropriate filters given as input in
# batches. The output is given in the form of a CSV file.
def batchDataRetrieval(startDateString, endDateString, folderPath,
                       listOfQuarterlyDatasets):

    # We create an appropriate output dataframe with four different columns as
    # requested.
    outputDataframe = pd.DataFrame(columns=['RSSD ID', 'Entity Type', 'Name' +
                                            ' of Institution', 'State or Co' +
                                            'untry', 'Start Date', 'End Date',
                                            'Regulatory District', 'Mnemoni' +
                                            'c and Item Code', 'Item Name',
                                            'Item Value', 'Date of Informat' +
                                            'ion Collection', 'Reporting Form'])

    # We convert the ending date provided as user input into a format that can
    # be manipulated.
    if endDateString != "":
        endDate = datetime.strptime(endDateString, '%d/%m/%Y')

    # If the input provided by the user is empty (meaning the case is still
    # ongoing), we assume that the ending date is the 31st of March, 2021.
    else:
        endDate = datetime.strptime("31/03/2021", '%d/%m/%Y')

    # We convert the starting date provided as user input into a format that can
    # be manipulated.
    startDate = datetime.strptime(startDateString, '%d/%m/%Y')

    # This variable is used to store the list of files that are compatible with
    # the starting and ending date filters provided by the user using a function
    # we defined previously.
    listOfCompatibleFiles = findListOfQuarterlyDatasetsFromDates(startDate,
                                                                 endDate, listOfQuarterlyDatasets)

    # This list is used to store the different information for each item code
    # available from the Codes.csv file using a function we defined previously.
    listOfDictionaryInformation = readDictionaryDataframeInBatches(startDate,
                                                                   endDate,
                                                                   folderPath)

    # We are reading the Banks.csv file and we are converting it into a Pandas
    # dataframe so we can obtain the relevant information from it.
    banksDataframe = pd.read_csv(folderPath + "/Banks.csv")

    # We are iterating through the MDRM dictionary to find the item code for the
    # item name requested by the user.
    for index, row in banksDataframe.iterrows():

        # This variable stores the starting date for the MDRM dictionary data.
        rssdID = str(row["RSSD ID"])
        institutionName = row["Name of Institution"]

        # This variable is used to store the relevant output data elements that
        # we will need later using a function we defined previously.
        listOfHoldingCompanyData = readListDataframe(rssdID, institutionName,
                                                     startDate, endDate,
                                                     folderPath)

        # We are iterating through the files that are compatible with the input
        # dates to find the information regarding the items requested by the
        # user.
        for fileName in listOfCompatibleFiles:

            # We are reading one of the quarterly historic dataset files and we
            # are converting it into a Pandas dataframe so we can obtain the
            # relevant information from it.
            mainDataframe = pd.read_csv(folderPath + "/Quarterly_Data/" +
                                        fileName, engine="python")

            # We are iterating through the specific quarterly historic dataset
            # file to find if there are any items that we can include in our
            # output.
            for index, row in mainDataframe.iterrows():

                # Since the headers of different quarterly historic datasets
                # differ, we have two different ways to read the ID and the
                # dates from it.
                try:
                    id = str(row["rssd9001"])
                    dateOfCollection = datetime.strptime(str(row["rssd9999"]),
                                                         "%Y%m%d")
                except:
                    id = str(row["RSSD9001"])
                    if id == "--------":
                        continue
                    dateOfCollection = datetime.strptime(str(row["RSSD9999"]),
                                                         "%Y%m%d")

                # We are converting the date the item was recorded into a string
                # that can be used in the output.
                outputDateOfCollection = dateOfCollection.strftime("%d/%m/%Y")

                # This is used to check if the RSSD ID matches with the user
                # input.
                if (id == rssdID):

                    # Since we have multiple item codes, we are finding the
                    # value for each of them.
                    for i in range(len(listOfDictionaryInformation)):

                        # We are checking if the value of the item requested is
                        # valid or not. If it is valid, we add the relevant data
                        # including the value of the item to the outputDataframe
                        # we created earlier.
                        try:
                            itemValueIndex = listOfDictionaryInformation[i][0]
                            outputItemValue = float(row[itemValueIndex])
                            if np.isnan(outputItemValue):
                                raise Exception("Value invalid!")
                            outputDataframe = outputDataframe.append({'RSSD ID':
                                                                      rssdID, 'Entity Type':
                                                                      listOfHoldingCompanyData[0],
                                                                      'Name of Institution':
                                                                      institutionName, 'State or Country':
                                                                      listOfHoldingCompanyData[1],
                                                                      'Start Date': startDateString,
                                                                      'End Date': endDateString,
                                                                      'Regulatory District':
                                                                      listOfHoldingCompanyData[2],
                                                                      'Mnemonic and Item Code':
                                                                      listOfDictionaryInformation[i][0],
                                                                      'Item Name':
                                                                      listOfDictionaryInformation[i][1],
                                                                      'Item Value':
                                                                      outputItemValue,
                                                                      'Date of Information Collection':
                                                                      outputDateOfCollection,
                                                                      'Reporting Form':
                                                                      listOfDictionaryInformation[i][2]},
                                                                     ignore_index=True)

                        # If the value of the item requested is invalid, we
                        # continue to the next iteration of the loop.
                        except:
                            continue

    # If the outputDataframe has no records, it means the search yielded no
    # results.
    if outputDataframe.empty:
        sys.exit("\nThe combination of inputs provided yielded no results. Pl" +
                 "ease run the program again \nwith different inputs!")

    # If the outputDataframe is not empty, we convert it into an Output.csv file
    # which can be viewed by the user.
    else:
        outputDataframe.to_csv('Output.csv')
        print()
        print("Please open the Output.csv file to see the result of your sear" +
              "ch criteria.")


# This is the main part of the program.
if __name__ == "__main__":

    # This variable stores the information regarding whether or not the user
    # has the relevant files needed for the program already available on Google
    # Drive
    filesOnDrive = input("Are the files necessary for this program available " +
                         "on Google Drive? Reply with a \n'Yes' or 'No'. ")
    print()

    # We are checking the result of the user's response. If the user does not
    # have the files on Google Drive, the program downloads the necessary files
    # in the appropriate format. The user must then upload the files to Google
    # Drive and run the program again.
    if filesOnDrive.lower() == "No".lower():

        # We use the function we defined previously to download all the the
        # necessary files (and converting them to suitable formats if
        # necessary) from their respective links.
        print("The program will download the relevant files and convert them " +
              "into usable formats.\nWARNING: This may take approximately 45 " +
              "minutes.\n")
        downloadHistoricalQuarterlyDatasets("https://www.chicagofed.org/banki" +
                                            "ng/financial-institution-reports" +
                                            "/bhc-data")
        downloadHoldingCompanyNameList("https://www.chicagofed.org/~/media/ot" +
                                       "hers/banking/financial-institution-re" +
                                       "ports/hc-name-list-pdf.pdf?la=en")
        convertPDFtoCSV("List.pdf", "List.csv")
        downloadMicroDataReferenceManual("https://www.federalreserve.gov/apps" +
                                         "/mdrm/pdf/MDRM.zip")

        # Once all the files needed have been downloaded, we display a message.
        print("All relevant files have been downloaded. Please create a folde" +
              "r called 'Data \nRetrieval' and add the Quarterly_Data folder " +
              "along with the List.csv and \nDictionary.csv files to it. Uplo" +
              "ad the Data Retrieval folder to Google Drive and \nrun the pro" +
              "gram again. ")

    # If the files are present in Google Drive, we can proceed with the program.
    else:

        # This variable stores the path of the Data Retrieval folder needed for
        # the program.
        folderPath = input("Please enter the path of of the Data Retrieval fo" +
                           "lder that you uploaded to Google \nDrive: ")

        # This variable is used to store all the historical quarterly datasets.
        listOfQuarterlyDatasets = os.listdir(folderPath + "/Quarterly_Data")
        listOfQuarterlyDatasets.remove(".ipynb_checkpoints")
        print()

        # This variable stores the way the user would like to execute this
        # program, providing more flexibility.
        programChoice = input("There are two ways two ways to execute this pr" +
                              "ogram:\n1. You want to find the information fo" +
                              "r one specific institution by providing \n   t" +
                              "he starting/ending date filters, the RSSD ID, " +
                              "the name of the institution, \n   the item tha" +
                              "t you are looking for, and the reporting form " +
                              "for the item.\n2. You want to find the informa" +
                              "tion for several institutions by using a CSV f" +
                              "ile \n   called Banks.csv containing the RSSD " +
                              "ID and the institution name. A different \n   " +
                              "CSV file called Codes.csv containing item code" +
                              "s for the information you want \n   must also " +
                              "be provided. After this, you must set the star" +
                              "ting/ending date\n   filters to finalise the s" +
                              "earch query.\nWhich option number would you li" +
                              "ke to execute? ")
        print()

        # This is used to prompt the user for the starting date as input to use
        # as a filter in the program if needed.
        startDateString = input("Enter the starting date filter in DD/MM/YYYY" +
                                " format: ")

        # This is used to prompt the user for the ending date as input to use as
        # a filter in the program if needed.
        endDateString = input("Enter the ending date filter in DD/MM/YYYY for" +
                              "mat (leave blank to check until \n31/03/2021): ")

        # If the user only wants to find information for one institution, he/she
        # would choose the first option.
        if programChoice == "1":

            # This is used to prompt the user for the RSSD ID as input to
            # proceed with the program.
            rssdID = input("Enter the RSSD ID for which you would like the in" +
                           "formation for: ")

            # This is used to prompt the user for the name of the institution as
            # input to proceed with the program.
            institutionName = input("Enter the name of the institution you wo" +
                                    "uld like the information for: ")

            # This is used to prompt the user for the item name as input to
            # display the information the user would like.
            itemName = input("Enter the name of the item for which you would " +
                             "like the information for: ")

            # This is used to prompt the user for the type of reporting form
            # used on the item name.
            reportingForm = input("Enter the reporting form of the item name " +
                                  "(leave blank if unavailable): ")

            # We use the function we defined previously to get data from the
            # different files and output it in a CSV file.
            dataRetrieval(startDateString, endDateString, rssdID,
                          institutionName, itemName, reportingForm, folderPath,
                          listOfQuarterlyDatasets)

        # If the user wants to find information for multiple institutions,
        # he/she would choose the second option.
        elif programChoice == "2":
            batchDataRetrieval(startDateString, endDateString, folderPath,
                               listOfQuarterlyDatasets)

        # # An example to demonstrate the correct running of the function with
        # # pre-determined inputs.
        # listOfQuarterlyDatasets = os.listdir("/content/drive/MyDrive/Education Essentials/University of Birmingham/UoB Data Analyst/Data Retrieval/Quarterly_Data")
        # listOfQuarterlyDatasets.remove(".ipynb_checkpoints")
        # dataRetrieval("01/01/2000", "31/12/2000", "1073757", "Bank of America Corporation", "Total Assets", "FR Y-9C", "/content/drive/MyDrive/Education Essentials/University of Birmingham/UoB Data Analyst/Data Retrieval", listOfQuarterlyDatasets)
        # batchDataRetrieval("01/01/2000", "31/12/2010", "/content/drive/MyDrive/Education Essentials/University of Birmingham/UoB Data Analyst/Data Retrieval", listOfQuarterlyDatasets)
